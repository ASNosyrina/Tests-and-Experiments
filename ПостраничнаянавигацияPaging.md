# Настройка визуального представления компонента "Постраничная навигация" (Paging )

В данной статье мы рассмотрим компонент "Постраничная навигация" и его возможности для настройки визуального представления. 

Компонент "Постраничная навигация" представляет собой мощный инструмент, который позволяет разработчикам реализовывать пагинацию в веб-приложениях. С помощью этого компонента возможно улучшить пользовательский опыт, разделяя большие наборы данных на более управляемые страницы.


## Установка и импорт компонента
Прежде чем приступить к настройке, убедитесь, что у вас установлен пакет `wasaby-controls`, содержащий компонент "Постраничная навигация". Для установки выполните следующую команду:

```jsx
npm install wasaby-controls
```

После установки компонента, импортируйте его в вашем приложении:

```jsx
import { Paging } from 'wasaby-controls';
```


## Основные возможности

### 1. Создание экземпляра компонента

Компонент "Постраничная навигация" предлагает набор элементов управления пагинацией, которые позволяют пользователям перемещаться по разным страницам данных. Эти элементы управления включают "Предыдущая страница", "Следующая страница" и возможность напрямую переходить на конкретную страницу.

```jsx
import { Paging } from 'wasaby-dev/Controls';

// Создаем экземпляр компонента "Постраничная навигация"
const paging = new Paging();

// Рендерим элементы управления пагинацией
paging.render(document.getElementById('pagination-container'));
```

Приведенный выше код демонстрирует создание экземпляра компонента "Постраничная навигация" и его последующий рендеринг в определенном контейнере на веб-странице.

#
### 2. Опции для настройки пагинации

1. __arrowState__ - управляет возможностью показа/скрытия стрелок-кнопок в пэйджинге, которые указывают на предыдущую и следующую страницы. Если значение этой опции установлено в false, стрелки не отображаются. Пример настройки:

	```jsx
	arrowState: false
	```

2. __contentTemplate__ - управляет отображением произвольного HTML-шаблона внутри пэйджинга, что позволяет пользователю настроить внешний вид компонента по своему усмотрению. Например, можно добавить дополнительные элементы, такие как иконки, текст или изображения.
	
    ```jsx
	contentTemplate: ‘<div class=“custom-template”>Страница #:page </div>’
	```

3. __contrastBackground__ определяет контрастность фона кнопки по отношению к его окружению. Это полезно для создания более заметных кнопок на фоне. 
Значение может быть установлено в _true_ или _false_. Если установлено значение _false_, фон кнопки будет того же цвета, что и его окружение.

	```jsx
	contrastBackground: true
    ```

4. __digitRenderCallback__ позволяет задавать отображение эмодзи вместо чисел страниц. Эта опция представляет собой функцию, которая устанавливает соответствие между номером страницы и определенным эмодзи. Например, вы можете использовать эту опцию для отображения смайликов вместо номеров страниц:

	```jsx
	digitRenderCallback(pageNumber) {
	if (pageNumber === 1) {
			return‘⬅️’;
		} else if (pageNumber === this.pages) {
			return ‘➡️’;
		} else {
			return‘’;
		}
	},
	```
5. __elementsCount__ задает количество элементов, которое должно отображаться на каждой странице. Это полезно, если вы хотите ограничить количество элементов на странице, чтобы улучшить производительность вашего приложения.
	
    ```jsx
    elementsCount: 10
    ```
6. __notLoadThemes__ флаг, который отключает загрузку переменных темы оформления для контролей.
Если вы не хотите, чтобы ваш компонент наследовал тему оформления из родительского элемента, вы можете отключить загрузку переменных темы, установив флаг notLoadThemes в _true_. Это может быть полезно, если необходимо использовать свой собственный стиль для вашего компонента. Вот пример использования этой опции:

	```jsx
	import {Paging} from “@wasaby - ui / controls”;

	function MyComponent() {
		return ( < Paging notLoadThemes = {
			true
		}
		pagesCount = {
			5
		}
		pagingMode = “simple”selectedPage = {
			1
		}
		showDigits = {
			false
		}
		theme = “light” / >);
	}
	```

7. __pagesCount__: Размер страницы

	Параметр pagesCount позволяет определить количество страниц, которое будет отображаться в постраничном навигаторе. По умолчанию установлено значение 10, но вы можете изменить его в соответствии с вашими требованиями. Вот пример изменения размера страницы:

	```jsx
	import { Paging } from “@wasaby-ui/controls”;

	function MyComponent() {
		return ( < Paging pagesCount = {
			7
		}
		pagingMode = “simple”
        selectedPage = {
			4
		}
		showDigits = {
			true
		}
		theme = “dark” / >);
	}
    ```
    
8. __pagingMode__: Внешний вид постраничной навигации

	Опция pagingMode позволяет определить внешний вид постраничного навигатора. Существует три возможных значения: simple, advanced и custom.

	* __Simple__ отображает только номера страниц и выбранную страницу.
	* __Advanced__ отображает номера страниц, выбранную страницу и общее количество страниц.
	* __Custom__ позволяет определить стиль каждой части навигатора с помощью CSS.
	
    Вот пример использования опции pagingMode для выбора внешнего вида постраничного навигатора:
    
	```jsx
	import { Paging, PagingMode } from “@wasaby-ui/controls”;

	function MyComponent() {
		return ( < Paging pagingMode = {
			PagingMode.advanced
		} > pagesCount = {
			10
		}
		selectedPage = {
			3
		}
		showDigits = {
			true
		}
		theme = “custom” < /Paging>
	);
	}
	```

9. __selectedPage__: Номер выбранной страницы

	Эта опция позволяет определить номер выбранной страницы в постраничном навигаторе. Если этот параметр не задан, то постраничный навигатор будет отображать первую страницу. Вот пример настройки номера выбранной страницы:

	```jsx
	import { Paging } from “@wasaby–ui/controls”;

	function MyComponent() {
		return ( < Paging pagesCount = {
			15
		}
		selectedPage = {
			5
		}
		showDigits = {
			true
		} > theme = “light” < /Paging>
	);
	}
    ```
	
10. __showDigits__: Отображать кнопки с номерами страниц
	
    Параметр showDigits определяет, будут ли отображаться кнопки с номерами страниц в постраничном навигаторе. Значения могут быть _true_ или _false_. 
    
    По умолчанию значение равно _true_, что означает, что кнопки с номерами страниц будут отображаться. Вот пример отключения отображения кнопок с номерами страниц:
	
    ```jsx	
	import { Paging } from “@wasaby-ui/controls”;

	function MyComponent() {
		return ( < Paging pagesCount = {
			50
		}
		selectedPage = {
			25
		}
		showDigits = {
			false
		} > theme = “dark” < /Paging>
	);
	}
	```
11. __theme__: Название темы оформления

	Параметр theme позволяет выбрать тему оформления для вашего постраничного навигатора из списка доступных тем. Вот пример выбора темы оформления:
   
    ```jsx
	import { Paging } from “@wasaby-ui/controls”;

	function MyComponent() {
		return ( < Paging pagesCount = {
			20
		}
		selectedPage = {
			10
		} > showDigits = {
			true
		}
		theme = “custom” < /Paging>
	);
	}
	```
#
  ### 3. Поля
  
####  Название компонента в библиотечной нотации
В поле **_$moduleNameInLibrary** указывается имя модуля компонента в формате X.Y, где X - имя библиотеки, а Y - имя компонента внутри этой библиотеки. Это поле используется для корректного отображения компонента в библиотеке.

```jsx
_$moduleNameInLibrary: 'my-library.paging',
```
#### Список зарегистрированных обработчиков _notify
Поле **_needRemoveBeforeUnmount** содержит список функций, которые должны быть вызваны перед размонтированием компонента. Это необходимо для очистки ресурсов, используемых компонентом.
```jsx
  _needRemoveBeforeUnmount: [
    () => {
      // код для очистки ресурсов
    },
  ],
```
#### Опции декорирования
Поле **_decOptions** используется для определения опций декорирования компонента. Декорирование - это процесс добавления дополнительных свойств и методов к базовому классу. В нашем случае, это позволяет добавить дополнительные стили или поведение к компоненту.

Например, мы можем определить стиль для кнопки “Предыдущая страница”:

```jsx
 _decOptions: {
    style: {
      previousButton: {
        backgroundColor: 'red',		// присвоили фону красный цвет
      },
    },
 },
 ```
#### Логический родитель
Поле **_logicParent** определяет логического родителя компонента. Это может быть использовано для добавления зависимостей или для передачи данных между компонентами.

Пример использования логического родителя для передачи данных:
```jsx
const {
	createElement,
	Component
} = window.React;

class App extends Component {
	constructor(props) {
		super(props);
		this.state = {
			data: [],
		};
	}

	componentDidMount() {
		fetch(‘https: //jsonplaceholder.typicode.com/posts’)
		.then((response) = >response.json()).then((data) = >{
			this.setState({
				data
			});
		});
	}

	render() {
		return ( < div > <PagingList data = {
			this.state.data
		}
		/>
</div > );
	}
}

function PagingList({
	data
}) {
	const {
		page,
		pageSize,
		totalItems,
		items,
		onPageSizeChange,
		onPageChange
	} = useStatePaging({
		page,
		pageSize,
		totalItems,
		items,
	});

	return ( < Paging logicParent = {
		App
	}
	onPageSizeChange = {
		onPageSizeChange
	}
	onPageChange = {
		onPageChange
	}
	/>
);
}
```
В этом примере, компонент PagingList передает данные о списке постов (state.data) компоненту Paging через логического родителя. Таким образом, компонент Paging может обновлять список постов при изменении страницы или размера страницы.

#### Передача параметров (_oldOptions)

Опции, которые были до рендеринга контрола, могут быть переданы как параметр в следующие хуки жизненного цикла: _afterRender и _afterUpdate.
Пример кода:

```jsx
<Paging
    oldOptions={{
        pageSizes: [10, 20, 30],
        pageSize: 10
    }}
/>
```

#### Стили (_styles)  
Поле  **_styles** содержит массив названий нетематизированных стилей, которые необходимы контролу. Стили будут загружены при создании компонента.
Пример:
```jsx
styles={['my-style', 'another-style']}
```
Здесь названия стилей должны быть заданы с префиксом “wasaby-”.

#### Тема (_theme)
Аналогично предыдущему пункту, это массив имен тематизированных стилей, которые нужны контролу.
Пример использования:
  
```jsx  
theme={['myTheme', 'anotherTheme']}
```

#### Перенос всех дочерних элементов элемента-родителя в начало его содержимого

**_transferChildrenToParent** - эта опция используется для переноса _children родителя из обертки над чистым React, чтобы он работал.
Пример кода:
```jsx  
transferChildrenToParent={true}
```

#### Дети (children)
Все дети контрола, которые имеют атрибут name. Примером может служить следующий код:

```jsx  
<PagingContext>
  <PagingControl name="home" />
  <PagingControl name="about" />
</PagingContext>;
```

#### Контекст (contexType)

Контекст с двумя опциями: _ReadOnly_ и _Theme_. 

Контекст — это механизм, который позволяет передавать информацию между компонентами без использования пропсов. 

_ReadOnly_ используется для указания, является ли контрол доступным только для чтения или нет.
```jsx 
{ readonly: true, }
```
_Theme_ — это объект, который содержит информацию о стилях для контрола. Примерами могут быть:

```jsx 
{ theme: { backgroundColor: 'red', color: 'white', }, }
```

#### Опции контрола (options)
Options - это реальные опции, которые можно настроить. Эти опции собираются из props, но могут не всегда совпадать с ними, чтобы обеспечить правильные значения в хуках. Опции можно настроить с помощью следующих полей:

* currentPage: номер текущей страницы.
* pageSize: количество элементов на странице.
* totalCount: общее количество элементов.
* pageCount: количество страниц.
* onChange: функция, вызываемая при изменении текущей страницы. 

Пример:
```jsx 
const onChange = (page) => { // обработать изменение текущей страницы };
```

#### Шаблон (template)
Шаблон контрола позволяет определить, как будет выглядеть контрол. Например, можно добавить кнопки вперед/назад, кнопки для изменения количества элементов на странице и т.д. Вот пример кода с комментариями:

```jsx 
<PagingTemplate>
  <!-- Добавляем кнопки "вперед" и "назад" --> 
{ ({
		currentPage,
		pageSize,
		totalCount,
		onChange
	}) = >( < div > <button type = “button”onClick = { () = >onChange(currentPage - 1)
	} > Назад < /button>
<span>Страница {currentPage}</span > /
<span>{pageCount}</span >

	<button type = "button"onClick = { () = >onChange(currentPage + 1)
	} > Вперед < /button>
</div > )
} < /PagingTemplate>;
```
#
### 4. Методы компонента "Постраничная навигация"

#### _afterMount
**_afterMount** - хук жизненного цикла контрола. Этот метод вызывается сразу после того, как компонент был установлен в DOM. Он позволяет выполнить дополнительные действия после интеграции компонента в страницу.

```jsx 
import { Paging } from 'wasaby.dev';

function App() {
  return (
    <Paging afterMount={() => {
      // Выполняем дополнительные действия, такие как добавление стилей или скриптов
    }} />
  );
}
```
#### _afterRender 
**_afterRender** - хук жизненного цикла контрола.
Этот метод выполняется синхронно после применения изменений к DOM и перед тем, как браузер начнет отрисовывать страницу.

```jsx 
<Paging
  afterRender={(node) => {
    // Применяем стили к компоненту после его рендеринга
  }}
/>
```
#### _afterUpdate
**_afterUpdate** - асинхронный хук жизненного цикла контрола.
   
Метод вызывается после того, как состояние компонента было обновлено. Это асинхронный метод, который ожидает завершения обновления состояния компонента.

```jsx 
// Обновляем состояние компонента при вызове метода
this.setState({
  data: newData
});

// Вызываем afterUpdate после обновления состояния
this.afterUpdate(() => {
  // Здесь выполняем дополнительные действия после обновления компонента
});
```

#### _beforeMount
**_beforeMount** - хук жизненного цикла контрола.

Этот хук вызывается перед интеграцией компонента в DOM, что позволяет разработчику выполнить предварительные действия перед интеграцией.

В примере ниже показано, как использовать _beforeMount для проверки наличия необходимых данных перед интеграцией компонента:

```jsx 
function App(props) {
  const [data, setData] = useState(null);

  function checkData() {
    if (data) {
      return;
    }

    fetch('https://jsonplaceholder.typicode.com/users')
      .then(response => response.json())
      .then((json) => {
        setData(json);
      });
  }

  useEffect(() => {
    checkData();  
}, []);

if (!data) {
return null;
}
return <Paging
beforeMount={checkData}
data={data}
/>;
}
```

#### _beforeRender 
Первый хук жизненного цикла контрола и единственный хук, который вызывается как на стороне сервера, так и на стороне клиента.

Он вызывается до рендеринга шаблона, поэтому обычно используется для подготовки данных для шаблона.

Пример использования _beforeRender:

```jsx 
import React, { useState } from "react";
import { Paging } from "@wasaby/react-paging";

function PageNavigation() {
  const [currentPage, setCurrentPage] = useState(0);

  // Устанавливаем начальное значение текущей страницы
  useEffect(() => {
    setCurrentPage(0); 
  }, []);

  return (
    <div>
      <Paging
        pageSize={10} // Количество элементов на странице
        totalItems={100} // Общее количество элементов
        currentPage={currentPage} // Текущая страница   
onPageChange={newPage => setCurrentPage(newPage)} // Реагируем на изменение текущей страницы
beforeRender={() => setCurrentPage(5)} // Изменяем текущую страницу после рендера на 5
/>
</div>
);
}
```
#### _beforeUnmount
Это последний хук жизненного цикла контрола. Контрол не будет существовать после вызова этого хука.

Служит для очистки состояния контрола, отписок от событий и т.д. После вызова этого метода любое взаимодействие с контролом (обращения к свойствам, вызовы методов и т.д.) является ошибкой.

В этом методе не нужно зачищать поля контрола, т.к. Wasaby делает это автоматически.

#### _beforeUpdate 
Служит для изменения состояния в ответ на изменение опций. Старые опции доступны на this._options, новые приходят первым аргументом.


Вызывается перед тем, как контрол обновится с новыми опциями. Вызывается после каждого обновления состояния контрола.

Не забывайте сравнивать старые и новые опции перед изменением состояния.
Пример использования:

```jsx 
function PageNavigation({
	totalItems,
	pageSize
}) {
	// Текущая страница, которая обновляется при изменении страницы
	const[currentPage, setCurrentPage] = React.useState(0);
	React.useEffect(() = >{
		// Инициализируем данные при монтировании
		setTimeout(() = >setCurrentPage((pageSize * 2) - 1), 500);
	},
	[]);

	const handlePageChange = newPage = >{
		if (newPage !== currentPage) {
			setCurrentPage(newPage);
		}
	};

	const beforeUpdate = () = >{
		// Изменяем данные после изменения страницы
		setCurrentPage((currentPage + 1));
	};

	return ( < >{
		/* Отображаем постраничную навигацию */
	} < div > <Paging pageSize = {
		pageSize
	}
	totalItems = {
		totalItems
	}
	currentPage = {
		currentPage
	}
	onPageChange = {
		handlePageChange
	}
	beforeUpdate = {
		beforeUpdate
	}
	/>
</div > </>
);
}
```

#### _componentDidMount 
Синхронный хук жизненного цикла контрола. Вызывается сразу после установки контрола в DOM-окружение.

Первый хук жизненного цикла контрола, который вызывается после подключения контрола к DOM-окружению.

На этом этапе вы можете получить доступ к параметрам и контексту this._options.

Этот хук жизненного цикла часто используется для доступа к DOM-элементам и подписки на события сервера.

Пример:

```jsx 
_componentDidMount(){
  this.setState({ isMounted: true });
  console.log("Component mounted successfully");
}
```
В этом примере мы используем _componentDidMount для установки состояния isMounted в true и вывода сообщения в консоль при первом монтировании компонента в DOM.

#### _shouldUpdate
Метод **_shouldUpdate** используется для определения того, должен ли текущий контрол быть обновлен. Он вызывается каждый раз до того, как контроллер будет обновлен. Если метод возвращает _true_, то контроллер будет обновлен, если же он возвращает _false_, то обновление контроллера будет пропущено.

```jsx 
_shouldUpdate(nextProps, nextState) {
  return nextProps.someProp !== this.props.someProp;
}
```

#### activate
Метод __activate__ используется для активации контрола. Он может быть использован для выполнения каких-либо действий при активации контрола или для инициализации каких-либо переменных.

```jsx 
activate() {
  // ...
}
```

#### createControl

Метод **createControl** используется для создания контрола и монтирования его на указанный элемент. Он принимает элемент DOM и опции контрола в качестве аргументов и возвращает созданный контрол.

```jsx 
const control = createControl(element, {
  data: this.state.data,
  onDataChange: this.onDataChange,
});
```

#### extend

Старый способ наследования, позволяющий наследоваться от родительского класса и переопределять его методы и свойства.
Пример использования:

```jsx 
import { Paging } from "wasaby.dev";  

class CustomPaging extends Paging {  
  constructor(props) {  
    super(props);  
  }  
  
  render() {  
    return (  
      <div>  
        My custom Paging component  
      </div>  
    );  
  }  
}  
```
#### loadCSS
__loadCSS__ - это метод, используемый для загрузки стилей и тем контролов. Он принимает путь к CSS файлу и опциональный объект опций в качестве параметров и загружает указанный CSS файл.

Вот пример его использования:

```jsx 
import { loadCSS } from "wasaby.dev"

// Загрузка CSS файла
loadCSS("path/to/your.css")

// Использование опций
loadCSS("path/to/your.css", {
  minify: true,
})
```

#### mountToDom
Для обратной совместимости не рекомендуется использовать __mountToDom__. 

Вот пример использования:

```jsx 
import { mountToDom } from ‘wasaby.dev’;

const element = document.getElementById(‘root’);

mountToDom(element);
```

#### saveOptions
Для обратной совместимости не рекомендуется использовать __saveOptions__. 

Вот пример его использования:

```jsx 
import { saveOptions } from ‘wasaby.dev’;

saveOptions({
debug: true, // Отладка
production: false // Производство
});
```
#
### 5. События 

Помимо возможности настройки внешнего вида, компонент "Постраничная навигация" поддерживает события, которые позволяют обрабатывать различные действия пользователя:  

1. Активированное событие (__activated__) происходит, когда пользователь активирует контрол. Это может быть, например, клик по кнопке перехода на страницу или прокрутка колесика мыши.

	Пример использования:
	```jsx 
	pagingControl.on(‘activated’, function(e) {
	console.log(‘Активирован контрол’);
	});
	```jsx 
2. Деактивированное событие (__deactivated__) происходит при деактивации контрола, например при потере фокуса.

	Пример использования:  
    ```jsx 
	pagingControl.on(‘deactivated’, function(e) {
	console.log(‘Деактивирован контрол’);
	});
	```

3. Событие __onArrowClick__ происходит при клике по кнопкам навигации: первая страница, последняя страница, следующая страница или предыдущая страница. 
 
 	Пример использования:   
	```jsx  
	var page = 1;
	pagingControl.onArrowClick = function(direction, page) {   
	page = page;
	console.log("Нажали на стрелку: " + direction + ", текущая страница: " + page);
	};
   ```
#   
### 6. Использование тайпдефов для изменения названия кнопок

Для изменения названий кнопок можно использовать тайпдефы.

Например, чтобы изменить название кнопки “Назад” на “Previous”, вы можете определить тайпдеф следующим образом:

```jsx
interface PagingButtonName extends Paging['ButtonName'] {
  Prev: 'Previous';
}
В этом случае, при создании экземпляра класса Paging, необходимо указать тип названия кнопки:

const paging: Paging & PagingButtonName = new Paging();
Вариант значения “Next” будет отображаться как “Next”. В следующем примере кнопка “Назад” будет называться “Previous”:

<Button onClick={paging.prev}>Previous</Button>
```
